
#version 430 core

layout ( quads ) in;

// MAX_DEGREE in u or v = (MAX_NUM_CONTROL_POINTS - 1)
uniform sampler2D snowMap;

uniform mat4 og_mc_ec;
uniform mat4 ec_lds;
uniform float season = 0;
uniform float snowScale = 1;
uniform vec2 snowMapDim = vec2(10, 10);

// These incoming values will be disregarded
in PVA
{
	vec3 ecPosition;
	vec3 ecUnitNormal;
	vec2 texCoords;
	float snow;
} pvaIn[];

out PVA
{
	vec3 ecPosition;
	vec3 ecUnitNormal;
	vec2 texCoords;
	float snow;
} pvaOut;

float lookupNoise(vec2 pos){
	pos -= snowMapDim/2;
	return texture(snowMap, vec2(pos.x, pos.y) / snowMapDim).r * 0.5 - 0.26;
}

vec4 evaluatePointOnSurface(float u, float v)
{
	vec4 p1 = mix(gl_in[0].gl_Position, gl_in[1].gl_Position, u);
	vec4 p2 = mix(gl_in[2].gl_Position, gl_in[3].gl_Position, u);
	vec4 pos = mix(p1, p2, v);

	pos = inverse(og_mc_ec) * pos;
	pos.y += lookupNoise(pos.xz);
	return pos;
}


vec3 evaluateNormalAtPoint(vec4 mcPos, float u, float v)
{
	float inc = 0.001;
	float xUpHeight = lookupNoise(vec2(mcPos.x + inc, mcPos.z));
	float xDownHeight = lookupNoise(vec2(mcPos.x - inc, mcPos.z));
	float zUpHeight = lookupNoise(vec2(mcPos.x, mcPos.z + inc));
	float zDownHeight = lookupNoise(vec2(mcPos.x, mcPos.z - inc));
	vec3 gradX = vec3(mcPos.x + inc, xUpHeight, 0) - vec3(mcPos.x - inc, xDownHeight, 0);
	vec3 gradZ = vec3(0, zUpHeight, mcPos.z + inc) - vec3(0, zDownHeight, mcPos.z - inc);
	vec3 normal = normalize(cross(gradX, gradZ));
	return normalize(transpose(inverse(mat3x3(og_mc_ec))) * normal);
}

void main()
{
	float u = gl_TessCoord[0];
	float v = gl_TessCoord[1];

	vec2 texCoord1 = mix(pvaIn[0].texCoords, pvaIn[1].texCoords, u);
	vec2 texCoord2 = mix(pvaIn[2].texCoords, pvaIn[3].texCoords, u);
	vec2 texCoords = mix(texCoord1, texCoord2, v);
	pvaOut.texCoords = texCoords;

	vec4 mcPos = evaluatePointOnSurface(u, v);
	pvaOut.ecUnitNormal = evaluateNormalAtPoint(mcPos, u, v);
	vec2 snowCoords = mcPos.xz / snowMapDim;
	float ecNormalInY = dot(pvaIn[0].ecUnitNormal, (transpose(inverse(mat3x3(og_mc_ec))) * vec3(0, 1, 0)).xyz);
	pvaOut.snow = 0;
	if(ecNormalInY > 0.6 && season > texture(snowMap, snowCoords).r - 0.2){
		mcPos.xyz += ecNormalInY * vec3(0, 1, 0) * 0.1 * season / snowScale;
		pvaOut.snow = 1;
	}
	mcPos = og_mc_ec * mcPos;
	pvaOut.ecPosition = mcPos.xyz/mcPos.w;
	gl_Position = ec_lds * mcPos;
}
